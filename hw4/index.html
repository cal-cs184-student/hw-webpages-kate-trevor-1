<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 4 Write-Up</h1>
		<div style="text-align: center;">Names: Samhita Ghosh, Stacey Lei </div>

		<br>

		Link to webpage: <a href="https://github.com/cal-cs184-student/hw-webpages-kate-trevor-1">https://github.com/cal-cs184-student/hw-webpages-kate-trevor-1</a>

		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw4-1stfloorsoda">https://github.com/cal-cs184-student/sp25-hw4-1stfloorsoda</a>

		<figure>
			<img src="clothsim.png" alt="Cloth draped over sphere" style="width:70%"/>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Thoughout this assignment, we implemented a cloth simulation using a mass-spring system and then explored various methods for handling collisions. To do so, we computed the force on each point mass and implemented Verlet's Integration to compute the position of the cloth at each time step. To make our cloth simulation more realistic, we added constraints to the system to prevent the cloth from over-stretching. We also added accounted for self-collisions and collisions against other objects, such as a sphere or plane. Finally, we wrote various shaders such as diffuse, Blinn-Phong, and texture mapping. Bump and displacement mapping were also implemented to add more realism to the cloth simulation.

		<h2>Part 1: Masses and springs</h2>
		<p>
			The first step of this project was the create the mass-spring grid. Below are some screenshots of the grid with different constraints visible.
		</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			<tr>
				<td style="text-align: center;">
					<img src="withoutshearing.png" width="400px"/>
					<figcaption>Without Shearing</figcaption>
				</td>
				<td style="text-align: center;">
					<img src="withoutshearingcloseup.png" width="400px"/>
					<figcaption>Without Shearing Close-Up</figcaption>
				</td>
			</tr>
			  <tr>
				<td style="text-align: center;">
					<img src="onlyshearing.png" width="400px"/>
					<figcaption>Only Shearing Constraints</figcaption>
				  </td>
				  <td style="text-align: center;">
					<img src="onlyshearingcloseup.png" width="400px"/>
					<figcaption>Only Shearing Constraints Close-Up</figcaption>
				  </td>
			</tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="spring4alltogether.png" width="400px"/>
				  <figcaption>All Constraints</figcaption>
				</td>
				<td style="text-align: center;">
					<img src="allspringcloseup.png" width="400px"/>
					<figcaption>All Constraints Close-Up</figcaption>
				  </td>
			  </tr>
			</table>
		</div>

		<h2>Part 2: Simulation via numerical integration</h2>
		<p>
			For the second task, we computed the total force on each point mass and used Verlet's Integration to compute the position of the cloth at each time step. We also added constraints to the system to prevent the cloth from stretching more than 1.1x its resting length. 
		</p>
		<p>
			Once our implementation was complete, we began experimenting with different parameters. When changing the ks (spring constant), we observed that a lower ks value resulted in a looser cloth whereas a higher ks value correlated with a tighter cloth. Below, we have included some screenshots of the cloth simulation with different ks values; the 1,000 N/m cloth has the most stretching (most prominent folds) compared to the default 5,000 N/m and 15,000 N/m cloths. On a similar note, the 15,000 N/m is the stiffest, exhibited by its minimal folds.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			<tr>
				<td style="text-align: center;">
					<img src="1000ks2pin.png" width="400px"/>
					<figcaption>1,000 N/m Cloth</figcaption>
				</td>
				<td style="text-align: center;">
					<img src="5000ks2pin.png" width="400px"/>
					<figcaption>5,000 N/m Cloth</figcaption>
				</td>
				<td style="text-align: center;">
					<img src="15000ks2pincloth.png" width="400px"/>
					<figcaption>15,000 N/m Cloth</figcaption>
				</td>
			</tr>
			</table>
		</div>
		<p>
			With lower density values, the cloth bounces less due to the lower mass at each point. Visually, it appears lighter as it is able to hang closer to its two pins. Vice versa, the higher density cloth (70 g/cm^2) is heavier and thus, it bounces more. It also hangs lower than the other two cloths. 
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			<tr>
				<td style="text-align: center;">
					<img src="1density.png" width="400px"/>
					<figcaption>1 g/cm^2</figcaption>
				</td>
				<td style="text-align: center;">
					<img src="5000ks2pin.png" width="400px"/>
					<figcaption>15 g/cm^2</figcaption>
				</td>
				<td style="text-align: center;">
					<img src="70density.png" width="400px"/>
					<figcaption>70 g/cm^2</figcaption>
				</td>
			</tr>
			</table>
		</div>
		<p>
			In terms of damping, a higher damping value results in a slower cloth falling animation and has less of a bounce. The lower damping values allows for the cloth to fall faster and bounce more (more follow-through after the initial drop). 
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			<tr>
				<td style="text-align: center;">
					<img src="0.1damping.png" width="400px"/>
					<figcaption>0.1% damping bouncing back</figcaption>
				</td>
				<td style="text-align: center;">
					<img src="5000ks2pin.png" width="400px"/>
					<figcaption>0.5% damping</figcaption>
				</td>
				<td style="text-align: center;">
					<img src="0.8damping.png" width="400px"/>
					<figcaption>0.8% damping falling down</figcaption>
				</td>
			</tr>
			</table>
			<p> 
				Below, is what the cloth looks like with default parameters and 4 pinned corners instead of 2.
			</p>
			<figure>
				<img src="4pinshaded.png" alt="Shaded 4 Pin Cloth" style="width:70%"/>
			</figure>
	
		</div>
		
		<h2>Part 3: Handling collisions with other objects</h2>
		<p>
			To handle collisions with spheres, we first checked if the position was inside of the sphere by checking the distance between the point mass and the center of the sphere. If the point mass's position is inside the sphere, we determined the tangent point (the point on the sphere closest to the point mass) and then moved the point mass to that tangent point. We calculated how much to move the last position (correction vector) by subtracting the tangent point from the last position. We then added that value scaled by the friction (1 - f) to the current position to get the new position.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">

		<table style="width: 100%; text-align: center; border-collapse: collapse;">
			<tr>
				<td style="text-align: center;">
					<img src="500 ks sphere.png" width="400px"/>
					<figcaption>500 N/m Sphere</figcaption>
				</td>
				<td style="text-align: center;">
					<img src="5000 ks sphere.png" width="400px"/>
					<figcaption>5000 N/m Sphere</figcaption>
				</td>
			</tr>
			<tr>
				<td style="text-align: center;">
					<img src="50000 ks sphere.png" width="400px"/>
					<figcaption>50,000 N/m Sphere</figcaption>
				</td>
			</tr>
		</table>
		</div>
		<p>
			The spring constants of the sphere (ks) also impacted the cloth simulation. For the 500 N/m sphere, the cloth was the stretchiest and had the most folds. The default 5,000 N/m sphere was the most stable and had the least amount of folds. The 50,000 N/m sphere was the stiffest and had the largest/least number of folds.
		</p>
		<p>
			For handling collision with the plane, we followed a similar approach, beginning with a check on whether the point mass's position and last position were on different sides of the plane (took the dot product of the last position or position subtracted by the point against the normal). If they were, then we calculated the distance from the point mass to the plane and then found its corresponding tangent (position subtracted by distance). We also added a small offset to the tangent point to move the cloth up. The offset was reversed if the point mass was below the plane. Finally, we updated the position of the point mass based on the offset + last position + correction vector scaled by the friction (1 - f). Here, we used an LLM to help us with the inside checker code, originally, we were not subtracting by the point, which led to an incorrect distance calculations if our position doesn't intersect with the origin. This interaction helped us better visualize our code and understand the math behind it.
		</p>
	
		<figure>
			<img src="peaceful plane.png" alt="Peaceful Plane" style="width:70%"/>
			<figcaption>Cloth On a Plane</figcaption>
		</figure>

		<h2>Part 4: Handling self-collisions</h2>
		To implement self-collision, we iterated through each point mass (candidates) and calculated its distance from the parameter point mass. If the distance was less the 2*thickness and the candidate point mass was not the same as the point mass passed in, we would determine its correction vector by multiplying the direction by the distance - 2*thickness. The correction for each point is then averaged and scaled by the simulation step before it is added to the point mass's position.

		<h2>Part 5: Shaders</h2>
		In the graphics pipeline, a shader is a program that works in parallel to compute visual properties like color and lighting effects. Apart from raytracing, shaders are frequently written in GLSL and are used to translate input data into a final 4D vector (RGBA) color output for each position, simulating various textures and materials on 3D objects.
		The vertex shader and the fragment shader are the two primary shader types that combine to produce visual realism in OpenGL. For activities like applying displacement maps, the vertex shader changes each vertex's location and normal vectors before passing the updated data onward. After rasterization, the fragment shader uses the interpolated geometry data from the vertex shader to process each generated fragment, which is a sample of pixels. The pixel-level details that show on the screen are created by computing the final color at each position and writing it to out_color.
		The shaders control how light interacts with objects which we need for realistic rendering.

		The Blinn-Phong shading model incorporates three essential lighting elements:
		Ambient: This refers to consistent background illumination that softens harsh shadows in poorly lit regions. It provides the object with a baseline lighting and is controlled by the coefficient k_a.
		Diffuse: Depending on the angle between the surface normal and the light source, diffue shading uses Lambert's Cosine Law to determine how much light strikes a surface directly. The diffuse component reflects the object's base hue and is independent of the viewerâ€™s perspective.
		Specular: Depending on the viewing angle, specular shading creates the illusion of glittering highlights. Blinn-Phong uses the angle between the surface normal and the bisector between the light direction and the view direction. The p value controls the sharpness of the specular highlight and controls the rate at which the highlight deviates from the point of maximum reflection. A narrower and glossier highlight is the result of a higher p value.
		To determine the final shaded color of each point on the surface, the three components are first calculated independently and then merged.

		<!-- ADD COMME NTS ON BUMP VS DISPLACEMENT MAPPING -->
		</div>
	</body>
</html>